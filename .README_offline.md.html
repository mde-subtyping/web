<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/Users/ab373/Documents/ArturData/WORK/git/web/.README_offline.md.html</title>


<style type="text/css">
body {
	color: #333;
	font: 13px/1.4 "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
	padding: 0;
	margin: 0;
}

a {
	background: transparent;
	color: #4183c4;
	text-decoration: none;
}

a:active,
a:hover {
	outline: 0 none;
	text-decoration: underline;
}

abbr[title] {
	border-bottom: 1px dotted;
}

b,
strong {
	font-weight: bold;
}

dfn {
	font-style: italic;
}
h1 {
	font-size: 2em;
	margin: 0.67em 0;
}
mark {
	background: #ff0;
	color: #000;
}
small {
	font-size: 80%;
}
sub, sup {
	font-size: 75%;
	line-height: 0;
	position: relative;
	vertical-align: baseline;
}
sup {
	top: -0.5em;
}
sub {
	bottom: -0.25em;
}
img {
	border: 0 none;
}
svg:not(:root) {
	overflow: hidden;
}
figure {
	margin: 1em 40px;
}
hr {
	box-sizing: content-box;
	height: 0;
}

code,
kbd,
pre,
samp {
	font-family: monospace,monospace;
	font-size: 1em;
}

pre {
	overflow: auto;
	font: 12px Consolas,"Liberation Mono",Menlo,Courier,monospace;
	margin-bottom: 0;
	margin-top: 0;
}

.markdown-body {
	padding: 30px;
	font-size: 16px;
	line-height: 1.6;
	word-wrap: break-word;
}

.markdown-body>*:first-child {
	margin-top: 0 !important;
}

.markdown-body>*:last-child {
	margin-bottom: 0 !important;
}

.markdown-body .absent {
	color: #c00;
}

.markdown-body .anchor {
	position: absolute;
	top: 0;
	bottom: 0;
	left: 0;
	display: block;
	padding-right: 6px;
	padding-left: 30px;
	margin-left: -30px;
}

.markdown-body .anchor:focus {
	outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
	position: relative;
	margin-top: 1em;
	margin-bottom: 16px;
	font-weight: bold;
	line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
	display: none;
	color: #000;
	vertical-align: middle;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
	padding-left: 8px;
	margin-left: -30px;
	line-height: 1;
	text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
	display: inline-block;
}

.markdown-body h1 tt,
.markdown-body h1 code,
.markdown-body h2 tt,
.markdown-body h2 code,
.markdown-body h3 tt,
.markdown-body h3 code,
.markdown-body h4 tt,
.markdown-body h4 code,
.markdown-body h5 tt,
.markdown-body h5 code,
.markdown-body h6 tt,
.markdown-body h6 code {
	font-size: inherit;
}

.markdown-body h1 {
	padding-bottom: 0.3em;
	font-size: 2.25em;
	line-height: 1.2;
	border-bottom: 1px solid #eee;
}

.markdown-body h2 {
	padding-bottom: 0.3em;
	font-size: 1.75em;
	line-height: 1.225;
	border-bottom: 1px solid #eee;
}

.markdown-body h3 {
	font-size: 1.5em;
	line-height: 1.43;
}

.markdown-body h4 {
	font-size: 1.25em;
}

.markdown-body h5 {
	font-size: 1em;
}

.markdown-body h6 {
	font-size: 1em;
	color: #777;
}

.markdown-body p,.markdown-body blockquote,
.markdown-body ul,.markdown-body ol,
.markdown-body dl,.markdown-body table,
.markdown-body pre {
	margin-top: 0;
	margin-bottom: 16px;
}

.markdown-body hr {
	height: 4px;
	padding: 0;
	margin: 16px 0;
	background-color: #e7e7e7;
	border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
	padding-left: 2em;
}

.markdown-body ul.no-list,
.markdown-body ol.no-list {
	padding: 0;
	list-style-type: none;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
	margin-top: 0;
	margin-bottom: 0;
}

.markdown-body li>p {
	margin-top: 16px;
}

.markdown-body dl {
	padding: 0;
}

.markdown-body dl dt {
	padding: 0;
	margin-top: 16px;
	font-size: 1em;
	font-style: italic;
	font-weight: bold;
}

.markdown-body dl dd {
	padding: 0 16px;
	margin-bottom: 16px;
}

.markdown-body blockquote {
	padding: 0 15px;
	color: #777;
	border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
	margin-top: 0;
}

.markdown-body blockquote>:last-child {
	margin-bottom: 0;
}

.markdown-body table {
	display: block;
	width: 100%;
	overflow: auto;
	word-break: normal;
	word-break: keep-all;
}

.markdown-body table th {
	font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
	padding: 6px 13px;
	border: 1px solid #ddd;
}

.markdown-body table tr {
	background-color: #fff;
	border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
	background-color: #f8f8f8;
}

.markdown-body img {
	max-width: 100%;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}

.markdown-body span.frame {
	display: block;
	overflow: hidden;
}

.markdown-body span.frame>span {
	display: block;
	float: left;
	width: auto;
	padding: 7px;
	margin: 13px 0 0;
	overflow: hidden;
	border: 1px solid #ddd;
}

.markdown-body span.frame span img {
	display: block;
	float: left;
}

.markdown-body span.frame span span {
	display: block;
	padding: 5px 0 0;
	clear: both;
	color: #333;
}

.markdown-body span.align-center {
	display: block;
	overflow: hidden;
	clear: both;
}

.markdown-body span.align-center>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: center;
}

.markdown-body span.align-center span img {
	margin: 0 auto;
	text-align: center;
}

.markdown-body span.align-right {
	display: block;
	overflow: hidden;
	clear: both;
}

.markdown-body span.align-right>span {
	display: block;
	margin: 13px 0 0;
	overflow: hidden;
	text-align: right;
}

.markdown-body span.align-right span img {
	margin: 0;
	text-align: right;
}

.markdown-body span.float-left {
	display: block;
	float: left;
	margin-right: 13px;
	overflow: hidden;
}

.markdown-body span.float-left span {
	margin: 13px 0 0;
}

.markdown-body span.float-right {
	display: block;
	float: right;
	margin-left: 13px;
	overflow: hidden;
}

.markdown-body span.float-right>span {
	display: block;
	margin: 13px auto 0;
	overflow: hidden;
	text-align: right;
}

.markdown-body code,.markdown-body tt {
	padding: 0;
	padding-top: 0.2em;
	padding-bottom: 0.2em;
	margin: 0;
	font-size: 85%;
	background-color: rgba(0,0,0,0.04);
	border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after,
.markdown-body tt:before,
.markdown-body tt:after {
	letter-spacing: -0.2em;
	content: "\00a0";
}

.markdown-body code br,
.markdown-body tt br {
	display: none;
}

.markdown-body del code {
	text-decoration: inherit;
}

.markdown-body pre>code {
	padding: 0;
	margin: 0;
	font-size: 100%;
	word-break: normal;
	white-space: pre;
	background: transparent;
	border: 0;
}

.markdown-body .highlight {
	margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
	padding: 16px;
	overflow: auto;
	font-size: 85%;
	line-height: 1.45;
	background-color: #f7f7f7;
	border-radius: 3px;
}

.markdown-body .highlight pre {
	margin-bottom: 0;
	word-break: normal;
}

.markdown-body pre {
	word-wrap: normal;
}

.markdown-body pre code,
.markdown-body pre tt {
	display: inline;
	max-width: initial;
	padding: 0;
	margin: 0;
	overflow: initial;
	line-height: inherit;
	word-wrap: normal;
	background-color: transparent;
	border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after,
.markdown-body pre tt:before,
.markdown-body pre tt:after {
	content: normal;
}

.highlight .pl-coc,
.highlight .pl-entl,
.highlight .pl-entm,
.highlight .pl-eoa,
.highlight .pl-mai .pl-sf,
.highlight .pl-mm,
.highlight .pl-pdv,
.highlight .pl-sc,
.highlight .pl-som,
.highlight .pl-sr,
.highlight .pl-v,
.highlight .pl-vpf {
	color: #0086b3;
}
.highlight .pl-eoac,
.highlight .pl-mdht,
.highlight .pl-mi1,
.highlight .pl-mri,
.highlight .pl-va,
.highlight .pl-vpu {
	color: #008080;
}
.highlight .pl-c,
.highlight .pl-pdc {
	color: #b4b7b4;
	font-style: italic;
}
.highlight .pl-k,
.highlight .pl-ko,
.highlight .pl-kolp,
.highlight .pl-mc,
.highlight .pl-mr,
.highlight .pl-ms,
.highlight .pl-s,
.highlight .pl-sok,
.highlight .pl-st {
	color: #6e5494;
}
.highlight .pl-ef,
.highlight .pl-enf,
.highlight .pl-enm,
.highlight .pl-entc,
.highlight .pl-eoi,
.highlight .pl-sf,
.highlight .pl-smc {
	color: #d12089;
}
.highlight .pl-ens,
.highlight .pl-eoai,
.highlight .pl-kos,
.highlight .pl-mh .pl-pdh,
.highlight .pl-mp,
.highlight .pl-pde,
.highlight .pl-stp {
	color: #458;
}
.highlight .pl-enti {
	color: #d12089;
	font-weight: bold;
}
.highlight .pl-cce,
.highlight .pl-enc,
.highlight .pl-kou,
.highlight .pl-mq {
	color: #f93;
}
.highlight .pl-mp1 .pl-sf {
	color: #458;
	font-weight: bold;
}
.highlight .pl-cos,
.highlight .pl-ent,
.highlight .pl-md,
.highlight .pl-mdhf,
.highlight .pl-ml,
.highlight .pl-pdc1,
.highlight .pl-pds,
.highlight .pl-s1,
.highlight .pl-scp,
.highlight .pl-sol {
	color: #df5000;
}
.highlight .pl-c1,
.highlight .pl-cn,
.highlight .pl-pse,
.highlight .pl-pse .pl-s2,
.highlight .pl-vi {
	color: #a31515;
}
.highlight .pl-mb,
.highlight .pl-pdb {
	color: #df5000;
	font-weight: bold;
}
.highlight .pl-mi,
.highlight .pl-pdi {
	color: #6e5494;
	font-style: italic;
}
.highlight .pl-ms1 {
	background-color: #f5f5f5;
}
.highlight .pl-mdh,
.highlight .pl-mdi {
	font-weight: bold;
}
.highlight .pl-mdr {
	color: #0086b3;
	font-weight: bold;
}
.highlight .pl-s2 {
	color: #333;
}
.highlight .pl-ii {
	background-color: #df5000;
	color: #fff;
}
.highlight .pl-ib {
	background-color: #f93;
}
.highlight .pl-id {
	background-color: #a31515;
	color: #fff;
}
.highlight .pl-iu {
	background-color: #b4b7b4;
}
.highlight .pl-mo {
	color: #969896;
}

</style>


<script type="text/javascript">

function getDocumentScrollTop() 
{
   var res = document.body.scrollTop || document.documentElement.scrollTop || window.pageYOffset || 0;
   // alert(res);
   return res;
}

function setDocumentScrollTop(ypos) 
{
	window.scrollTo(0, ypos);
}

</script>


</head>
<body class="markdown-body">
<h1> <a id="software-artifact-submission-for-sle17" class="anchor" href="#software-artifact-submission-for-sle17" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Software Artifact Submission for SLE'17</h1> 
<p>This document describes how to install and use the tool supporting the results of the paper <strong>Structural Model Subtyping with OCL Constraints</strong> by <strong>Artur Boronat (University of Leicester, UK)</strong>, accepted for publication at <a href="http://conf.researchr.org/track/sle-2017/sle-2017-papers">SLE@SPLASH'17</a>.</p> 
<h2> <a id="abstract" class="anchor" href="#abstract" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Abstract</h2> 
<p>Our tool facilitates the reuse of model management operations that are defined for metamodel specifications, which consist of an EMF metamodel together with its well-formedness constraints (in OCL). Specifically, our tool infers whether two metamodel specifications, whose metamodels and constraints need not be related a priori, are <em>compatible</em>. This captures the notion of subtype polymorphism in model management operations using structural model subtyping with optional OCL constraints. Our tool implements the structural subtyping relationship in a type-theoretic framework with multiple inheritance semantics and can be used for implementing various use cases in flexible model-driven engineering, for example: structural (semantic) refinement, evolution of domain-specific modelling languages, and reuse of model management operations.</p> 
<p>To deal with structural subtyping, the tool synthesizes an extension metamodel that is employed both to check the compatibility of OCL constraints and to reuse model management operations without requiring manual intervention. The extension metamodel can be obtained both for single and multiple inheritance contexts. Moreover, the tool produces complements of the supertype and subtype metamodel, w.r.t. the chosen subtyping relation, which can be used for guiding the reuse model management operations. In addition, our structural subtyping mechanism is expressive enough so as to support variants of model subtyping, including multiple, partial, and dynamic model subtyping.</p> 
<p>Our tool is available as a Java library together with a self-contained Gradle project that includes all the dependencies required for using the tool together with additional resources implementing the examples of the paper. The tool has been tested on <code>macOS 10.12.4 (Sierra)</code> and <code>Linux Ubuntu 15.04 (Vivid Vervet)</code>. In addition, a VirtualBox image with the Linux configuration is available for download.</p> 
<p>This document contains three main sections: an overview of the contents in the zipped file, an installation guide, and step-by-step instructions arranged in the form of specific scenarios for each of the use cases mentioned above. These step-by-step instructions illustrate the core contributions of the paper and show the full extent of the examples used in it. Moreover, these scenarios have been implemented in executable test cases in order to ensure the experimental reproducibility of the results of the paper.</p> 
<h2> <a id="overview-content-of-the-archive" class="anchor" href="#overview-content-of-the-archive" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview: content of the archive</h2> 
<p>The contents of the archive are as follows:</p> 
<ul> 
 <li> <a href="./.README.md.html">README.md</a>: this document 
  <ul> 
   <li>Setup/installation guide 
    <ul> 
     <li>Environment assumptions for using the tool</li> 
     <li>Getting the tool</li> 
     <li>Linux (VirtualBox): VirtualBox image with Eclipse pre-configured</li> 
    </ul> </li> 
   <li>Step-by-step instructions 
    <ul> 
     <li>Using the tool programmatically</li> 
     <li>Scenario 1: Structural subtyping (<strong>Subtyping</strong>)</li> 
     <li>Scenario 2: Structural subtyping with OCL constraints (<strong>Subtyping, Multiple-Typing</strong>)</li> 
     <li>Scenario 3: DSML evolution (<strong>Reuse, Partial Typing</strong>)</li> 
     <li>Scenario 4: Stepwise Simulation of Deterministic State Machines (<strong>Reuse, Dynamic Typing</strong>)</li> 
    </ul> </li> 
   <li>License</li> 
   <li>Credits</li> 
  </ul> </li> 
 <li> <a href="./.README_offline.md.html">README_offline.md</a>: offline version of the file <code>README.md</code>. The difference between these two files is that <code>README.md</code> is readable on GitHub and <code>README_offline.md</code> is pretty printed as <code>.README_offline.md.html</code>, which is readable in a browser offline - that is URL paths are accessible using <code>file:///</code> in the browser.</li> 
 <li> <a href="./.README_offline.md.html">.README_offline.md.html</a>: <code>README_offline.md</code> in HTML format. Images should be displayed correctly and there is no need to access any external resource unless the VirtualBox image is downloaded, in which case Google Drive will be accessed.</li> 
 <li>Three projects used in the examples that illustrate the step-by-step instructions: 
  <ul> 
   <li> <a href="./subtyping.tests">subtyping.tests</a>: main project that contains the main test cases and shows how to invoke the tool programmatically, including 
    <ul> 
     <li>how the tool supports <strong>structural subtyping with optional OCL constraints</strong> for checking structural refinement between metamodel specifications, formed by a metamodel and well-formedness constraints in OCL;</li> 
     <li> <strong>multiple model subtyping</strong>;</li> 
     <li>an scenario on DSML evolution illustrating how the tool provides support for <strong>partial model subtyping</strong>;</li> 
     <li>an scenario on state machine simulation illustrating how the tool provides support for <strong>dynamic model subtyping</strong>.</li> 
    </ul> </li> 
   <li> <a href="subtyping.sm.atl">subtyping.sm.atl</a>: ATL transformation (evolution) - ATL project containing the transformation needed to test the evolution scenario.</li> 
   <li> <a href="subtyping.sm.atl.simulation">subtyping.sm.atl.simulation</a>: ATL transformation (simulation) - ATL project containing the transformation needed to test the simulation scenario.</li> 
  </ul> </li> 
</ul> 
<h2> <a id="setupinstallation-guide" class="anchor" href="#setupinstallation-guide" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setup/installation guide</h2> 
<h3> <a id="environment-assumptions-to-use-the-tool" class="anchor" href="#environment-assumptions-to-use-the-tool" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Environment assumptions to use the tool</h3> 
<p>The tool has been tested on <code>macOS 10.12.4 (Sierra)</code> and <code>Linux Ubuntu 15.04 (Vivid Vervet)</code>. A VirtualBox image with Linux Ubuntu 15.04 is available, as explained below.</p> 
<p>The base technology that is required to run the tool is as follows:</p> 
<ul> 
 <li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html">Java 1.8</a></li> 
 <li><a href="http://groovy-lang.org/download.html">Groovy 2.4</a></li> 
 <li><a href="https://gradle.org/install/">Gradle 4.0</a></li> 
</ul> 
<p>Although the tool is usable in Eclipse-independent standalone mode, we recommend the use of Eclipse Modeling Tools for editing the models. To work with <a href="http://www.eclipse.org/downloads/packages/eclipse-modeling-tools/oxygenr">Eclipse Oxygen (Modelling Package)</a>, the following plugins need to be installed:</p> 
<ul> 
 <li><a href="http://www.eclipse.org/atl/download/">ATL</a></li> 
 <li><a href="https://github.com/groovy/groovy-eclipse/wiki">Groovy integration plugin</a></li> 
 <li><a href="https://marketplace.eclipse.org/content/buildship-gradle-integration">Gradle Buildship Integration 2.0</a></li> 
 <li><a href="https://marketplace.eclipse.org/content/epsilon">Epsilon Platform</a></li> 
</ul> 
<h3> <a id="getting-the-tool" class="anchor" href="#getting-the-tool" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting the tool</h3> 
<ol> 
 <li>Get the tool 
  <ul> 
   <li>From <strong>GitHub</strong>: clone the git repository: <code>https://github.com/mde-subtyping/web.git</code>.</li> 
   <li>From the <strong>zipped file</strong>: you should have unzipped the file to get this README file already.</li> 
  </ul> </li> 
 <li>Import the project with test cases: 
  <ul> 
   <li>From Java perspective: <code>Import &gt; Gradle project</code> </li> 
   <li>Select the project folder <code>subtyping.tests</code> in your git repository.</li> 
   <li>If prompted <code>Overwrite existing Eclipse project descriptors?</code>, choose <code>Overwrite</code>.</li> 
   <li>Use the option <code>Gradle wrapper</code>.</li> 
  </ul> </li> 
 <li>Import the ATL projects using <code>Import &gt; Import Existing Projects into Workspace</code>.</li> 
</ol> 
<p>By default, the tool is configured to run the examples for <strong>macOS</strong>.</p> 
<p>To run the tool on <strong>Linux</strong>, some configuration arguments need to be edited in the project <code>subtyping.tests</code>:</p> 
<ul> 
 <li> <p>In each of the packages under the folder <code>src/test/resources</code>, edit the file <code>subtyping.properties</code> and change the following parameter bindings as follows:</p> <pre><code>  maude.os=OS_LINUX
  maude.maudePath=src/test/resources/maude/maude.linux64 
</code></pre> </li> 
 <li> <p>Please check that the file <code>src/test/resources/maude/maude.linux64</code> is executable, or else modify the corresponding access permissions using <code>chmod</code>.</p> </li> 
</ul> 
<p>After that explore the test cases under <code>src/test/groovy</code>, which can be run as JUnit test cases. Follow the step-by-step instructions given below.</p> 
<h3> <a id="linux-virtualbox" class="anchor" href="#linux-virtualbox" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Linux (VirtualBox)</h3> 
<p>A VirtualBox image with <code>Linux Ubuntu 15.04 (Vivid Vervet)</code> and Eclipse configured to run the test cases is <a href="https://docs.oracle.com/cd/E26217_01/E26796/html/qs-import-vm.html">available for download</a>.</p> 
<ol> 
 <li>Download and install <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>.</li> 
 <li>Download the VirtualBox image <code>Ubuntu 15.04_SLE17.ova</code> from <a href="https://drive.google.com/file/d/0ByBrw5bkMQahOTZKTU1reHhXMk0/view?usp=sharing">Google Drive</a>.</li> 
 <li> <a href="https://docs.oracle.com/cd/E26217_01/E26796/html/qs-import-vm.html">Import the appliance in VirtualBox</a>.</li> 
 <li>In VirtualBox, right click on image and <code>Start &gt; Normal Start</code>.</li> 
 <li>Use the following credentials (User/password): ubuntu/reverse.</li> 
 <li>There is a direct link to <code>Eclipse Oxygen</code> on the desktop. Run Eclipse.</li> 
 <li>Follow the step-by-step instructions given below.</li> 
</ol> 
<h2> <a id="step-by-step-instructions" class="anchor" href="#step-by-step-instructions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step-by-step instructions</h2> 
<p>In the following subsections, we provide the examples used to illustrate the core contributions in the paper.</p> 
<h3> <a id="using-the-tool-programmatically" class="anchor" href="#using-the-tool-programmatically" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using the tool programmatically</h3> 
<p>The usual structure of a test exercising the subtyping operation is as follows:</p> 
<ul> 
 <li> <p>Load the configuration properties for the solver (an example can be found <a href="./subtyping.tests/src/test/resources/sle17/sm/example/subtyping.properties">here</a>) indicating where Maude is stored and the bounds to be used by the model finder:</p> <pre><code>  SolverProperties.loadPropertiesFile(propFilePath)
</code></pre> </li> 
 <li> <p>Create an instance of the tool and configure it:</p> <pre><code>  def ModelTypeUtils tool = new ModelTypeUtils()
  // whether the software artifacts involved in solution (reuse metamodel, complement metamodels, etc) are to be persisted
  tool.persistent=true
  // folder where software artifacts will be stored 
  tool.outputPath=&quot;src/test/resources/sle17/sm/example/generated/&quot;
  // whether to use multiple subtyping or strict subtyping
  tool.multipleInheritance = false
</code></pre> </li> 
 <li> <p>Invoke the tool by providing the metamodel specifications:</p> <pre><code>  tool.isOclConstrainedSubtypeOf(
  	sMMPath, // path to subtype EMF metamodel (.ecore)
  	sOcl, 	 // string containing OCL constraints for the metamodel above, or empty string otherwise
  	tMMPath, // path to supertype EMF metamodel (.ecore)
  	tOcl	 // string containing OCL constraints for the metamodel above, or empty string otherwise
  )
</code></pre> </li> 
</ul> 
<p>The tool will determine whether <code>(sMMPath,sOcl)</code> denotes a model subtype of the model type denoted by <code>(tMMPath,tOcl)</code>. This use case is illustrated in more detail below, in <strong>Scenario 1: Structural subtyping (Subtyping, Structural Refinement)</strong> and in <strong>Scenario 2: Structural subtyping with OCL constraints (Semantic Refinement, Multiple Typing)</strong>. Note that any of the sets of OCL constraints may be empty (with the empty string <code>&quot;&quot;</code>).</p> 
<ul> 
 <li>The tool generates the model binding <code>binding.xmi</code> containing bindings representing the possible multiple typings of classifiers in the subtype with classifiers of the supertype. This model is used to obtain: 
  <ul> 
   <li> <code>binding0_reuse_mm.ecore</code>: extension metamodel for reusing model management operations;</li> 
   <li> <code>binding0_subtype_uncovered.ecore</code>: classifiers of subtype that have not been covered by the subtyping relation (data types are always included);</li> 
   <li> <code>binding0_supertype_uncovered.ecore</code>: classifiers of supertype that have not been covered by the subtyping relation (data types are always included);</li> 
   <li> <code>binding0_virtual_mm.ecore</code>: extension metamodel used for the analysis of OCL constraints (supertype classifiers are abstract);</li> 
   <li> <code>binding0.xmi</code>: subtypeOf relationships considered.</li> 
  </ul> </li> 
 <li>If <code>tool.multipleInheritance = true</code> when configuring the tool instance, subsequent `bindingX files represent the strict typing solutions by order of recommendation prioritizing those with a better coverage of subtype classifiers with supertype classifiers, as explained in the paper. For each strict subtyping solution <em>X</em>, the models described above are also synthesized.</li> 
</ul> 
<p>If the check fails, there are two main sources of incompatibilities: the model types denoted by the metamodels, and the OCL constraints.</p> 
<ol> 
 <li>In the first case, the tool points at the source of the problem by showing the classes of the supertype metamodel <code>tMMPath</code> that are not extended by classes of <code>sMMPath</code> in the supertype complement <code>bindingX_supertype_uncovered.ecore</code>. That information is useful to assess the advantage of, for example, prunning the supertype metamodel by computing the effective metamodel w.r.t. a specific model management operation, as illustrated in <strong>Scenario 3: DSML evolution (Reuse, Partial Typing)</strong>.</li> 
 <li>In the second case, the tool will provide evidence that contradicts the compatibility property of <code>sOcl</code> w.r.t. <code>tOcl</code> in the form of a model conforming to the synthesized extension metamodel <code>bindingX_virtual_mm.ecore</code>, represented in EMF notation (that is in XMI format), that invalidates a constraint in <code>tOcl</code>. Note that the solver needs to be configured appropriately, in the configuration file as explained above, for increasing the likelihood of finding a problem if it exists.</li> 
</ol> 
<p>If the check succeeds, the tool guarantees that <code>(sMMPath,sOcl)</code> is a structural refinement of <code>(tMMPath,tOcl)</code>. Hence, any EMF model management operation that is defined for <code>(sMMPath,sOcl)</code> can be safely applied to models of <code>(tMMPath,tOcl)</code>. Going one step further, the tool also facilitates the reuse of such operation by automatically synthesizing an extension metamodel <code>bindingX_reuse_mm.ecore</code> that can be substituted for <code>tMMPath</code> in the signature of the operation ensuring its application to models conforming to <code>(sMMPath,sOcl)</code> without any further change. This use case is illustrated with two scenarios: <strong>Scenario 3: DSML evolution (Reuse, Partial Typing)</strong> and <strong>Scenario 4: Stepwise Simulation of Deterministic State Machines (Reuse, Dynamic Typing)</strong>.</p> 
<p>The scenarios below illustrate specific examples that have been used to support the results in the paper. These scenarios have been implemented in test cases for ensuring the reproducibility of the results.</p> 
<p><strong>Note:</strong> for inspecting the generated models using model editors in Eclipse, such as the EMF reflective editor or <a href="http://www.eclipse.org/epsilon/doc/articles/inspect-models-exeed/">Exeed</a>, the corresponding metamodel needs to be registered using Epsilon's <code>Register EPackages</code> facility in advance. This option appears when right-clicking on a metamodel <code>.ecore</code> in Eclipse. The reason for this is that synthesized metamodels reuse information from the original metamodels and the EMF registry needs to be updated to fetch the corresponding metamodel when loading a model.</p> 
<h3> <a id="scenario-1-structural-subtyping-subtyping-structural-refinement" class="anchor" href="#scenario-1-structural-subtyping-subtyping-structural-refinement" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scenario 1: Structural subtyping (Subtyping, Structural Refinement)</h3> 
<p>In this section, we show the expressivity of our structural subtyping operation (without OCL constraints) with respect to model typing [^Steel07] [^Guy12]. We compare our approach to model subtyping by considering their example with the following state machine metamodels:</p> 
<p>[^Steel07]: Jim Steel, Jean-Marc J&eacute;z&eacute;quel. On model typing. Software and Ssytem Modeling 6, 4 (2007), 401-413. [^Guy12]: Clement Guy, Beno&icirc;t Combemale, Steven Derrien, Jim Steel, Jean-Marc J&eacute;zequel. On Model Subtyping. ECMFA 2012. 400-415.</p> 
<p><a href="images/sm_subtyping.png" target="_blank"><img src="images/sm_subtyping.png" height="450" style="max-width:100%;" /></a></p> 
<p>where changes have been highlighted.</p> 
<p>The test cases implementing the subtyping checks can be found <a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_sm_subtyping.groovy">here</a> and the results are summarized in the following table:</p> 
<table> 
 <thead> 
  <tr> 
   <th>subtypeOf</th> 
   <th>sm1</th> 
   <th>sm2</th> 
   <th>sm3</th> 
   <th>&nbsp;sm4</th> 
   <th>sm5</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>sm1</td> 
   <td>true</td> 
   <td><strong>true</strong></td> 
   <td>false</td> 
   <td>false</td> 
   <td>false</td> 
  </tr> 
  <tr> 
   <td>sm2</td> 
   <td>false</td> 
   <td>true</td> 
   <td>false</td> 
   <td>false</td> 
   <td>false</td> 
  </tr> 
  <tr> 
   <td>sm3</td> 
   <td>true</td> 
   <td><strong>true</strong></td> 
   <td>true</td> 
   <td>false</td> 
   <td>false</td> 
  </tr> 
  <tr> 
   <td>sm4</td> 
   <td>true</td> 
   <td><strong>true</strong></td> 
   <td>false</td> 
   <td>true</td> 
   <td>false</td> 
  </tr> 
  <tr> 
   <td>sm5</td> 
   <td>true</td> 
   <td><strong>true</strong></td> 
   <td>false</td> 
   <td>false</td> 
   <td>true</td> 
  </tr> 
 </tbody> 
</table> 
<p>These results are consistent with those presented in [^Steel07] but for the cases where many-bounded references in a supertype are constrained by a lower upper bound in the corresponding subtype. In our tool, those cases are valid.</p> 
<h3> <a id="scenario-2-structural-subtyping-with-ocl-constraints-semantic-refinement-multiple-typing" class="anchor" href="#scenario-2-structural-subtyping-with-ocl-constraints-semantic-refinement-multiple-typing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scenario 2: Structural subtyping with OCL constraints (Semantic Refinement, Multiple Typing)</h3> 
<p>In this section, we use the main example of the paper for illustrating how <strong>multiple typings</strong> can be applied to a metamodel at the classifier level, that is, a class of the subtype metamodel can be typed by more than one class in the supertype metamodel. The generalization of multiple typing at the metamodel level, where several metamodels can be used as supertype of the same subtype metamodel, is supported by providing an extension metamodel for each different pair of metamodel specifications. However, as each such extension metamodel is linked to a different pair of metamodel specifications, with the intention of reusing a model management operation in a given context, we restrict ourselves to an example with one single model management operation.</p> 
<p>In the example, we are using the metamodel specifications depicted below for defining graphs (<a href="./subtyping.tests/src/test/resources/sle17/sm/example/graph.emf">metamodel</a> and <a href="./subtyping.tests/src/test/resources/sle17/sm/example/graph_ocl_mapProperty.use">OCL constraints</a>) and deterministic state machines (<a href="./subtyping.tests/src/test/resources/sle17/sm/example/sm.emf">metamodel</a> and <a href="./subtyping.tests/src/test/resources/sle17/sm/example/sm_ocl_det.use">OCL constraints</a>), resp. The model types described by both metamodels are structurally similar in that they both describe languages of graphs.</p> 
<p><a href="images/example.png" target="_blank"><img src="images/example.png" height="450" style="max-width:100%;" /></a></p> 
<p>On the one hand, the top metamodel specification characterizes the graph of a function defined over nodes. On the other hand, the bottom metamodel specification characterizes deterministic state machines where transitions can be triggered by an event (indicated in the <em>name</em> attribute of the transition) or are triggerless, e.g. they are completion transitions.</p> 
<p><a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_sm_example.groovy">These test cases</a> show how to use the tool to check that the state machine metamodel specification denotes a model subtype of the one denoted by the graph metamodel:</p> 
<ul> 
 <li>Using <a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_sm_example.groovy">strict subtyping (test_singleInheritance_isSubtypeOf_consistent)</a>:</li> 
 <li>Using <a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_sm_example.groovy">multiple subtyping (test_multipleInheritance_isSubtypeOf_consistent)</a>:</li> 
</ul> 
<p>Moreover, if we consider non-deterministic state machines by removing the OCL constraint defining the deterministic condition from the state machine metamodel specification as instructed in <a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_sm_example.groovy">this test case (test_singleInheritance_isSubtypeOf_inconsistent)</a> we obtain a non-deterministic state machine that does not satisfy the graph constraint, which is represented in object diagram notation as follows:</p> 
<p><a href="images/counterexample.png" target="_blank"><img src="images/counterexample.png" height="250" style="max-width:100%;" /></a></p> 
<p>The counterexample in generated in the folder <code>temp/model</code>, where <code>temp</code> is the temporary folder specified in the corresponding <em>subtyping.properties</em> file. The counterexample is a model conforming to the virtual metamodel and can be <em>casted down</em> to the subtype as explained in the sections below.</p> 
<p><a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_sm_event.groovy">These test cases</a> demonstrate the usage of the possible combinations of OCL constraints with metamodels for checking structural subtyping, showing that OCL constraints are optional in metamodel specifications.</p> 
<h3> <a id="scenario-3-dsml-evolution-reuse-partial-typing" class="anchor" href="#scenario-3-dsml-evolution-reuse-partial-typing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scenario 3: DSML evolution (Reuse, Partial Typing)</h3> 
<p>In this section, we are going to show how to reuse a model management operation - in this case, a model-to-text transformation with ATL - for a modified version of the state machine metamodel. In this scenario, we discuss how to use the tool to reuse an ATL model transformation defined for a metamodel <code>version 1</code> for models of a metamodel <code>version 2</code> when the metamodel <code>version 1</code> is not exactly a supertype of the metamodel <code>version 2</code>. In addition, we illustrate that the ATL model transformation can be applied even if a model is only <strong>partially typed</strong> by the metamodel involved in the ATL transformation.</p> 
<p>The steps involved in this scenario relating to our tool are fully automated in the test case <a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_evolution.groovy">test_evolution_scenario</a>. The steps that require interaction with ATL need to be carried out manually though.</p> 
<p><a href="./subtyping.sm.atl/models/smObservation.emf">Initial state machine metamodel</a> (<strong>version 1</strong>):</p> 
<p><a href="images/mm_SmObservation.png" target="_blank"><img src="images/mm_SmObservation.png" height="300" style="max-width:100%;" /></a></p> 
<p>We have developed an <a href="./subtyping.sm.atl/trafo/sm.atl">ATL transformation</a> that serializes a state machine conforming to the previous metamodel into the <a href="http://www.informit.com/articles/article.aspx?p=1592379&amp;seqNum=3">format proposed by Martin Fowler</a>:</p> 
<pre><code>query SM2Text = sm!StateMachine.allInstances()
		-&gt;asSequence()
		-&gt;first().compile().println();

helper context sm!StateMachine def: compile() : String =
	'events\n' +
	self.edges-&gt;iterate(e; acc : String = '' | acc + '  ' + e.name + '\n') +
	'end\n\n' +
	self.nodes-&gt;iterate(n; acc : String = '' | acc + n.compile() );
	
helper context sm!State def: compile() : String =
	'state ' + self.name + '\n' +
	sm!StateMachine.allInstances()-&gt;first().edges-&gt;iterate(e; acc : String ='' |
		if (e.source.name=self.name) then
			'  ' + e.name + ' =&gt; ' + e.target.name + '\n'
		else 
			''
		endif
	) +
	'end\n\n';
</code></pre> 
<p>This operation maps the state machine:</p> 
<p><a href="images/model_initial.png" target="_blank"><img src="images/model_initial.png" height="250" style="max-width:100%;" /></a></p> 
<p>into</p> 
<pre><code>events
  a-&gt;b
end

state a
  a-&gt;b =&gt; b
end

state b
end
</code></pre> 
<p>In an update of our DSL for state machines, a concept <em>Event</em> is added as an explicit class and the concept <em>Observation</em> is removed, producing a <a href="./subtyping.sm.atl/extended/smEvent.emf">new metamodel</a> (<strong>version 2</strong>):</p> 
<p><a href="images/mm_SmEvent.png" target="_blank"><img src="images/mm_SmEvent.png" height="300" style="max-width:100%;" /></a></p> 
<p>with the following constraint, ensuring the consistency of event names:</p> 
<pre><code>context Transition
inv event_consistency:
not(self.event.oclIsUndefined) implies self.name=self.event.name
</code></pre> 
<p>For which we can define state machines as follows:</p> 
<p><a href="images/model_smEvent.png" target="_blank"><img src="images/model_smEvent.png" height="250" style="max-width:100%;" /></a></p> 
<p>The questions that we address next are:</p> 
<ul> 
 <li>Can we reuse the model management operation for compiling state machines that conform to <code>version 2</code> of the metamodel (as the one depicted above)?</li> 
 <li>If so, how can we do it?</li> 
</ul> 
<p>Our subtyping operation assists us in determining that <code>version 2</code> of the metamodel together with the OCL constraint is a refinement of <code>version 1</code> as shown <a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_evolution.groovy">in this test case</a>, which is not due to the removal of the <strong>Observation</strong> concept. By looking at the generated binding file and at completement of the supertype metamodel (shown below), the modeller has information to find out the source of the problem.</p> 
<p><a href="images/mm_SupertypeComp.png" target="_blank"><img src="images/mm_SupertypeComp.png" height="175" style="max-width:100%;" /></a></p> 
<p>To see if there exists a potential valid refinement for reusing the operation, the user can extract the effective metamodel for the ATL transformation, either:</p> 
<ul> 
 <li> <strong>manually</strong> by inspecting the software artifacts generated by our tool and by inspecting the ATL transformation, which seems reasonable for an example of this size; or</li> 
 <li> <strong>automatically</strong> by using tools like <a href="http://sanchezcuadrado.es/projects/anatlyzer/">anATLyzer</a> that perform static analysis of ATL transformations.</li> 
</ul> 
<p>Our tool provides a facility for prunning a metamodel given the features of interest. The computed <a href="./subtyping.tests/src/test/resources/sle17/sm/evolution/smObservation_prunned.emf">effective metamodel</a> is as follows:</p> 
<p><a href="images/mm_SmObservationPrunned.png" target="_blank"><img src="images/mm_SmObservationPrunned.png" height="250" style="max-width:100%;" /></a></p> 
<p>The subtyping operation is used again to check whether the effective metamodel is a valid supertype for our metamodel (<code>version 2</code>), which is correct.</p> 
<p>The subtyping operation also synthesizes:</p> 
<ul> 
 <li>the <a href="./subtyping.sm.atl/extended/binding0_reuse_mm.emf">extension metamodel</a>, depicted in class diagram notation as follows</li> 
</ul> 
<p><a href="images/mm_SmExtension.png" target="_blank"><img src="images/mm_SmExtension.png" height="375" style="max-width:100%;" /></a></p> 
<ul> 
 <li>and the complement of the supertype and subtype metamodels. The complement of the subtype metamodel (shown below) tells us that the models of the subtype are only <strong>partially typed</strong> with the supertype metamodel, as the class <em>Event</em> is not covered.</li> 
</ul> 
<p><a href="images/mm_SubtypeComp.png" target="_blank"><img src="images/mm_SubtypeComp.png" height="175" style="max-width:100%;" /></a></p> 
<p>The extension metamodel, shown above, can be used to rewrite the signature of the model management operation. In addition, as the subtyping operation had to apply some automatic renamings in order to avoid name clashes, we have to adapt the original model that conforms to <strong>version 2</strong> to the extension metamodel as shown in the test case <a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_evolution.groovy">test_evolution_scenario</a>. This operation retypes the objects in the original model according to the renamings inferred by the subtyping operation:</p> 
<p><a href="images/model_renamed.png" target="_blank"><img src="images/model_renamed.png" height="250" style="max-width:100%;" /></a></p> 
<p>This model can be processed by the ATL transformation, after replacing the original metamodel with the synthesized extension metamodel. Note that the adaptation of the model is only mandatory when the set of class names in version 1 and the set of class names in version 2 are not disjoint.</p> 
<p>In case the renamings applied to the subtype metamodel in the extension model make the object type names different from those in the original subtype metamodel, the tool facilitates an adaptation from the extended metamodel to the original metamodel as explained in the following scenario.</p> 
<h3> <a id="scenario-4-stepwise-simulation-of-deterministic-state-machines-reuse-dynamic-typing" class="anchor" href="#scenario-4-stepwise-simulation-of-deterministic-state-machines-reuse-dynamic-typing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Scenario 4: Stepwise Simulation of Deterministic State Machines (Reuse, Dynamic Typing)</h3> 
<p>In this example, we are considering the reuse of an ATL transformation used in the paper for simulating deterministic state machines stepwise by using an ATL transformation that applies a function graph to a node. The difference with the evolution example is that the simulation example generates new elements in the transformation, which are automatically re-typed in our approach, illustrating how <strong>dynamic typing</strong> is supported.</p> 
<p>The steps in the scenario described below have been implemented in the test case <a href="./subtyping.tests/src/test/groovy/metamodel/sm/test_sle17_sm_simulation.groovy">test_simulation_scenario</a>. The resources used in the scenario are reachable from the implementation of the test case.</p> 
<ul> 
 <li>The graph metamodel that has been considered is</li> 
</ul> 
<p><a href="images/mm_graph.png" target="_blank"><img src="images/mm_graph.png" height="450" style="max-width:100%;" /></a></p> 
<ul> 
 <li> <p>with the well-formedness constraints</p> <pre><code>  context Edge
  inv map:
  not(Edge.allInstances()-&gt;exists(e | 
  	e.source=self.source
  	and
  	e.target&lt;&gt;self.target 
  ))
</code></pre> </li> 
 <li> <p>The <a href="./subtyping.sm.atl.simulation/trafo/simulation_sm.atl">ATL transformation</a>, shown below, applies a marking to the nodes of the graph by following the order imposed by the edges of the function graph. The execution of the ATL transformation simulates the application of the graph function to a node, when there is a successor node that has not been marked in the model.</p> <pre><code>  module simulation;
  create OUT : graph refining IN : graph;
  
  rule simulate {
  	from 
  		n1 : graph!State ( n1.mark.oclIsUndefined() and graph!Transition.allInstances()-&gt;exists( e | e.target=n1 and not e.source.mark.oclIsUndefined()) ) 
  	to
  		n2 : graph!State (
  			mark &lt;- m		
  		),
  		m : graph!Observation (
  			graph &lt;- n1.graph,
  			time &lt;- graph!Transition.allInstances()-&gt;select( e | e.target=n1 and not e.source.mark.oclIsUndefined())-&gt;asSequence()-&gt;first().source.mark.time + 1
  		)	
  }
</code></pre> </li> 
 <li> <p>An initial graph and the resulting graphs from applying the transformation twice, that is once to the input model and a second time to the model generated after step 1, are as follows:</p> </li> 
</ul> 
<p><a href="images/graph_simulation.png" target="_blank"><img src="images/graph_simulation.png" height="250" style="max-width:100%;" /></a></p> 
<p>In these models, we have obliterated the root object <em>Graph</em>.</p> 
<p>As discussed in the paper, the ATL transformation could be applicable to deterministic state machines to facilitate their simulation. The state machine metamodel that we are considering is</p> 
<p><a href="images/mm_simulation_sm.png" target="_blank"><img src="images/mm_simulation_sm.png" height="450" style="max-width:100%;" /></a></p> 
<p>with the well-formedness constraint</p> 
<pre><code>	context Transition
	inv determinism:
	not(Transition.allInstances()-&gt;exists(t | 
		t.source=self.source
		and
		t.target&lt;&gt;self.target 
	))
</code></pre> 
<p>To reuse the ATL transformation, we use the subtyping operation to obtain the reuse metamodel:</p> 
<p><a href="images/mm_simulation_reuse.png" target="_blank"><img src="images/mm_simulation_reuse.png" height="450" style="max-width:100%;" /></a></p> 
<p>In addition, we can check that the complement of the supertype metamodel only contains datatypes, indicating that all the supertype classifiers are covered by the subtyping relation and, hence, that the metamodel graph is indeed a supertype of the deterministic state machine metamodel specification.</p> 
<p><a href="images/mm_simulation_supertypeComp.png" target="_blank"><img src="images/mm_simulation_supertypeComp.png" height="200" style="max-width:100%;" /></a></p> 
<p>And that the complement of the subtype metamodel contains the references <code>initial</code>, <code>final</code> and <code>subMachines</code> between the classes <code>State</code> and <code>StateMachine</code>, indicating that the inferred subtyping is a <strong>partial typing</strong>.</p> 
<p><a href="images/mm_simulation_subtypeComp.png" target="_blank"><img src="images/mm_simulation_subtypeComp.png" height="200" style="max-width:100%;" /></a></p> 
<p>To <strong>reuse</strong> the ATL transformation for state machines, the model representing the state machine is re-typed to the extension metamodel, obtaining a model conforming to the extension metamodel, to which the ATL transformation can be applied. In this scenario, this step is optional as the re-typing does not apply any changes to the model. However, in general, such a re-typing may apply changes as illustrated in <strong>Scenario 3: DSML evolution (Reuse, Partial Typing)</strong>. After applying the ATL transformation, another model conforming to the extension metamodel is obtained where concepts from the supertype may have been created (such as <code>Mark</code>). A second re-typing is necessary in order to ensure that the produced model conforms to the original state machine metamodel. This process is illustrated as follows:</p> 
<p><a href="images/sm_simulation.png" target="_blank"><img src="images/sm_simulation.png" height="550" style="max-width:100%;" /></a></p> 
<p>As discussed in the paper, the subtyping relation must be strict in order for the last re-typing to work automatically.</p> 
<h2> <a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h2> 
<pre><code>MIT License

Copyright (c) 2017 Artur Boronat

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre> 
<h2> <a id="credits" class="anchor" href="#credits" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Credits</h2> 
<p>Our tool reuses (adapting and extending) the following third-party tools as libraries:</p> 
<ul> 
 <li> <a href="https://github.com/totem-mde/totem">TOTEM-MDE</a>: for integrating the USE validator with EMF.</li> 
 <li> <a href="https://sourceforge.net/projects/useocl/">USE validator</a> to reason about OCL constraints.</li> 
 <li>Maude4J: An Eclipse-independent version of <a href="http://mdt.sourceforge.net/">Maude Development Tools</a> for integrating Maude with Java.</li> 
</ul>
</body>
</html>
